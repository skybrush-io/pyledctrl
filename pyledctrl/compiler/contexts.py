"""Context objects for the bytecode compiler.

Context objects provide a dictionary mapping identifiers to functions that
are injected into the namespace in which the source code of a LED control
file is evaluated. This allows us to implement custom "commands" that the
user can use in a LED control file.
"""

from __future__ import absolute_import

from contextlib import contextmanager
from functools import partial
from . import bytecode


class ExecutionContext(object):
    """Base class for execution contexts.

    Execution contexts provide a dictionary mapping identifiers to functions
    that are injected into the namespace in which the source code of a LED
    control file is evaluated. This allows us to implement custom "commands"
    that the user can use in a LED control file.
    """

    def evaluate(self, code, add_end_command=False):
        """Evaluates the given Python code object in this execution context.

        :param code: the code to evaluate
        :param add_end_command: whether to add a terminating ``END`` command
            automatically to the end of the bytecode
        """
        global_vars = self.get_globals()
        exec(code, global_vars, {})
        if add_end_command:
            global_vars["end"]()

    def get_globals(self):
        """Returns a dictionary containing the global variables to be made
        available in the executed file."""
        raise NotImplementedError


class FileWriterExecutionContext(ExecutionContext):
    """Execution context that writes the generated bytecode in response to each
    command to a file-like object."""

    def __init__(self, fp):
        """Constructor.

        :param fp: a file-like object to write the generated bytecode to
        :type fp: file-like
        """
        self._fp = None
        self._globals = None
        self.fp = fp

    @property
    def fp(self):
        """The file-like object where the bytecode is written to."""
        return self._fp

    @fp.setter
    def fp(self, value):
        self._fp = value
        self._globals = None

    def get_globals(self):
        if self._globals is None:
            self._globals = self._construct_globals()
        return self._globals

    def _construct_globals(self):
        writer = partial(bytecode.writer_of, to=self.fp)
        result = {
            "_loop_begin": writer(bytecode.loop_begin),
            "_loop_end": writer(bytecode.loop_end),
            "end": writer(bytecode.end),
            "fade_to_black": writer(bytecode.fade_to_black),
            "fade_to_color": writer(bytecode.fade_to_color),
            "fade_to_gray": writer(bytecode.fade_to_gray),
            "fade_to_white": writer(bytecode.fade_to_white),
            "nop": writer(bytecode.nop),
            "set_black": writer(bytecode.set_black),
            "set_color": writer(bytecode.set_color),
            "set_gray": writer(bytecode.set_gray),
            "set_white": writer(bytecode.set_white)
        }
        aliases = dict(off="set_black", on="set_white")
        for alias, func in aliases.items():
            result[alias] = result[func]

        @contextmanager
        def _loop_context(iterations=None):
            result["_loop_begin"](iterations)
            yield
            result["_loop_end"]()

        result["loop"] = _loop_context
        return { k: v for k, v in result.items() if not k.startswith("_") }
