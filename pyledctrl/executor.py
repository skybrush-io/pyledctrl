"""Executor for abstract syntax trees generated by the LedCtrl compiler."""

from collections import namedtuple
from itertools import count
from numbers import Number

__all__ = ("Color", "ExecutorState", "Executor")


_Color = namedtuple("Color", "red green blue")
_Color.__new__.__defaults__ = (0, 0, 0)


class Color(_Color):
    """Color of LEDs on a LED strip."""

    @classmethod
    def black(cls):
        """Returns an instance of the color black."""
        return cls.gray(0)

    @classmethod
    def gray(cls, value):
        """Returns an instance of the color gray with the given value."""
        return cls(red=value, green=value, blue=value)

    @classmethod
    def white(cls):
        """Returns an instance of the color white."""
        return cls.gray(255)

    def update_from(self, obj):
        """Updates the color from another object that has ``red``, ``green``
        and ``blue`` properties containing numeric abstract syntax tree nodes,
        and returns the updated color.
        """
        return self._replace(
            red=obj.red.value, green=obj.green.value, blue=obj.blue.value
        )


class ExecutorState(object):
    """State of an executor object."""

    def __init__(self):
        self.timestamp = 0
        self.color = Color()
        self.is_fade = False

    def advance_time_by(self, duration):
        if not isinstance(duration, Number):
            # We assume that 'duration' is a numeric AST node and its value
            # gives the duration in units of 1/50 seconds
            duration = duration.value / 50.0
        else:
            # We assume that 'duration' specifies the duration in seconds
            pass
        self.timestamp += duration


class StopExecution(Exception):
    """Exception raised by an executor to stop execution."""

    pass


class Executor(object):
    """Executor for abstract syntax trees generated by the LedCtrl compiler.

    The executor manages the state of a virtual LED strip with red, green and
    blue channels, and is able to execute the command represented by any
    abstract tree node on the virtual LED strip. The executor method yields
    state objects for each interesting point in the execution where a color
    change occurs.
    """

    def __init__(self):
        """Constructor.

        Creates a virtual LED strip set to black color at timestamp zero.
        """
        self.state = ExecutorState()

    def execute(self, node):
        """Executes the command(s) in the given abstract syntax tree node
        and updates the state accordingly, yielding the state after every
        timestamp change.

        Note that the same state object is yielded repeatedly, so do not store
        a direct reference to it. If you need to keep the state permanently,
        create a deep copy.
        """
        try:
            for state in self._execute(node):
                yield state
        except StopExecution:
            pass

    def _execute(self, node):
        class_name = node.__class__.__name__
        method = getattr(self, "_execute_{0}".format(class_name), None)
        if method is None:
            raise RuntimeError("cannot execute {0}".format(class_name))

        for state in method(node):
            yield state

    def _execute_EndCommand(self, node):
        raise StopExecution()

    def _execute_FadeToBlackCommand(self, node):
        for state in self._fade_to(Color.black(), node.duration):
            yield state

    def _execute_FadeToColorCommand(self, node):
        for state in self._fade_to(
            Color(
                red=node.color.red.value,
                green=node.color.green.value,
                blue=node.color.blue.value,
            ),
            node.duration,
        ):
            yield state

    def _execute_FadeToGrayCommand(self, node):
        for state in self._fade_to(Color.gray(node.value.value), node.duration):
            yield state

    def _execute_FadeToWhiteCommand(self, node):
        for state in self._fade_to(Color.white(), node.duration):
            yield state

    def _execute_LoopBlock(self, node):
        num_iterations = node.iterations.value
        if num_iterations > 0:
            iterator = range(num_iterations)
        else:
            iterator = count()
        for i in iterator:
            for state in self._execute(node.body):
                yield state

    def _execute_NopCommand(self, node):
        return iter(())

    def _execute_SetBlackCommand(self, node):
        self.state.color = Color.black()
        self.state.is_fade = False
        yield self.state
        self.state.advance_time_by(node.duration)

    def _execute_SetColorCommand(self, node):
        self.state.color = self.state.color.update_from(node.color)
        self.state.is_fade = False
        yield self.state
        self.state.advance_time_by(node.duration)

    def _execute_SetGrayCommand(self, node):
        self.state.color = Color.gray(node.value.value)
        self.state.is_fade = False
        yield self.state
        self.state.advance_time_by(node.duration)

    def _execute_SetWhiteCommand(self, node):
        self.state.color = Color.white()
        self.state.is_fade = False
        yield self.state
        self.state.advance_time_by(node.duration)

    def _execute_StatementSequence(self, node):
        for statement in node.statements:
            for state in self._execute(statement):
                yield state

    def _execute_SleepCommand(self, node):
        self.state.advance_time_by(node.duration)
        self.state.is_fade = False
        yield self.state

    def _execute_WaitUntilCommand(self, node):
        new_timestamp = node.timestamp.value
        self.state.timestamp = max(self.state.timestamp, new_timestamp)
        self.state.is_fade = False
        yield self.state

    def _fade_to(self, color, duration):
        if not self.state.is_fade:
            yield self.state
            self.state.is_fade = True

        self.state.advance_time_by(duration)
        self.state.color = color
        yield self.state
